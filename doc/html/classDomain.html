<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Variant: Domain Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Variant
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classDomain-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Domain Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classDomain.html" title="Domain on which a scheme is executed. ">Domain</a> on which a scheme is executed.  
 <a href="classDomain.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="source_2subdomain_2Domain_8hpp_source.html">Domain.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6adccae537e53d4fde2b70f875e6b8d0"><td class="memItemLeft" align="right" valign="top"><a id="a6adccae537e53d4fde2b70f875e6b8d0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a6adccae537e53d4fde2b70f875e6b8d0">Domain</a> ()</td></tr>
<tr class="memdesc:a6adccae537e53d4fde2b70f875e6b8d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a6adccae537e53d4fde2b70f875e6b8d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29cec9afb2e54c810ba1f3c1a49543a8"><td class="memItemLeft" align="right" valign="top"><a id="a29cec9afb2e54c810ba1f3c1a49543a8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a29cec9afb2e54c810ba1f3c1a49543a8">~Domain</a> ()</td></tr>
<tr class="memdesc:a29cec9afb2e54c810ba1f3c1a49543a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a29cec9afb2e54c810ba1f3c1a49543a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853266061b629ff1f920b46c06c478d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a853266061b629ff1f920b46c06c478d6">initRect</a> (real lx, real ly, unsigned int Nx, unsigned int Ny)</td></tr>
<tr class="memdesc:a853266061b629ff1f920b46c06c478d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes domain rectangle.  <a href="#a853266061b629ff1f920b46c06c478d6">More...</a><br /></td></tr>
<tr class="separator:a853266061b629ff1f920b46c06c478d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a5e8384b21bb3c968699c2a6c89bf7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a10a5e8384b21bb3c968699c2a6c89bf7">setOptions</a> (unsigned int nSDD, unsigned int nSDD_X, unsigned int nSDD_Y, unsigned int nSDS, std::string SDSgeom, unsigned int nThreads)</td></tr>
<tr class="memdesc:a10a5e8384b21bb3c968699c2a6c89bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes options for building SDDs and SDSs.  <a href="#a10a5e8384b21bb3c968699c2a6c89bf7">More...</a><br /></td></tr>
<tr class="separator:a10a5e8384b21bb3c968699c2a6c89bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a510afad91fe81eb2ccef203a980f4223"><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a510afad91fe81eb2ccef203a980f4223">getlx</a> () const</td></tr>
<tr class="memdesc:a510afad91fe81eb2ccef203a980f4223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the non-modifiable width of the domain.  <a href="#a510afad91fe81eb2ccef203a980f4223">More...</a><br /></td></tr>
<tr class="separator:a510afad91fe81eb2ccef203a980f4223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9cedab179bb0611fc0e9fcfbcedb835"><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#ac9cedab179bb0611fc0e9fcfbcedb835">getly</a> () const</td></tr>
<tr class="memdesc:ac9cedab179bb0611fc0e9fcfbcedb835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the non-modifiable height of the domain.  <a href="#ac9cedab179bb0611fc0e9fcfbcedb835">More...</a><br /></td></tr>
<tr class="separator:ac9cedab179bb0611fc0e9fcfbcedb835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f299e3871fe9cec01637b140429ef9"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a75f299e3871fe9cec01637b140429ef9">getSizeX</a> () const</td></tr>
<tr class="memdesc:a75f299e3871fe9cec01637b140429ef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the non-modifiable number of cells on the x-axis.  <a href="#a75f299e3871fe9cec01637b140429ef9">More...</a><br /></td></tr>
<tr class="separator:a75f299e3871fe9cec01637b140429ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66692b4f23353c9b1fe884e583770cb3"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a66692b4f23353c9b1fe884e583770cb3">getSizeY</a> () const</td></tr>
<tr class="memdesc:a66692b4f23353c9b1fe884e583770cb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the non-modifiable number of cells on the y-axis.  <a href="#a66692b4f23353c9b1fe884e583770cb3">More...</a><br /></td></tr>
<tr class="separator:a66692b4f23353c9b1fe884e583770cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb586f6ef994a1621680ec9b946aeb4"><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#acdb586f6ef994a1621680ec9b946aeb4">getdx</a> () const</td></tr>
<tr class="memdesc:acdb586f6ef994a1621680ec9b946aeb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the non-modifiable space step on the x-axis (ie. the width of a cell).  <a href="#acdb586f6ef994a1621680ec9b946aeb4">More...</a><br /></td></tr>
<tr class="separator:acdb586f6ef994a1621680ec9b946aeb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e62ab8a8b53f67cc3c30b6066b10aac"><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a5e62ab8a8b53f67cc3c30b6066b10aac">getdy</a> () const</td></tr>
<tr class="memdesc:a5e62ab8a8b53f67cc3c30b6066b10aac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the non-modifiable space step on the y-axis (ie. the height of a cell).  <a href="#a5e62ab8a8b53f67cc3c30b6066b10aac">More...</a><br /></td></tr>
<tr class="separator:a5e62ab8a8b53f67cc3c30b6066b10aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978917d5bf263dd1345f1a41c9edf661"><td class="memItemLeft" align="right" valign="top"><a id="a978917d5bf263dd1345f1a41c9edf661"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>getNumberSDD</b> () const</td></tr>
<tr class="separator:a978917d5bf263dd1345f1a41c9edf661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02cc51cc2e5d976810039e7118382cde"><td class="memItemLeft" align="right" valign="top"><a id="a02cc51cc2e5d976810039e7118382cde"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>getNumberSDD_X</b> () const</td></tr>
<tr class="separator:a02cc51cc2e5d976810039e7118382cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8d6c959123597f6e2d8779a836d32c"><td class="memItemLeft" align="right" valign="top"><a id="a8e8d6c959123597f6e2d8779a836d32c"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>getNumberSDD_Y</b> () const</td></tr>
<tr class="separator:a8e8d6c959123597f6e2d8779a836d32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985c94d1108a0a206f0201908d944a0d"><td class="memItemLeft" align="right" valign="top"><a id="a985c94d1108a0a206f0201908d944a0d"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>getNumberNeighbourSDDs</b> () const</td></tr>
<tr class="separator:a985c94d1108a0a206f0201908d944a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a428011ce5e842c9f05545c57480ed30e"><td class="memItemLeft" align="right" valign="top"><a id="a428011ce5e842c9f05545c57480ed30e"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>getNumberPhysicalCells</b> () const</td></tr>
<tr class="separator:a428011ce5e842c9f05545c57480ed30e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbbd89acedd87b8b4814e367027551cd"><td class="memItemLeft" align="right" valign="top"><a id="adbbd89acedd87b8b4814e367027551cd"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>getNumberOverlapCells</b> () const</td></tr>
<tr class="separator:adbbd89acedd87b8b4814e367027551cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a77c402326dc31a855125536348a6f"><td class="memItemLeft" align="right" valign="top"><a id="ab3a77c402326dc31a855125536348a6f"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>getNumberBoundaryCells</b> () const</td></tr>
<tr class="separator:ab3a77c402326dc31a855125536348a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e60a79720035ab95a1eb4a41efb53c"><td class="memItemLeft" align="right" valign="top"><a id="a25e60a79720035ab95a1eb4a41efb53c"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>getNumberSDS</b> () const</td></tr>
<tr class="separator:a25e60a79720035ab95a1eb4a41efb53c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388103cf2adcc7224f77d4c26a471d6a"><td class="memItemLeft" align="right" valign="top"><a id="a388103cf2adcc7224f77d4c26a471d6a"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getSDSGeometry</b> () const</td></tr>
<tr class="separator:a388103cf2adcc7224f77d4c26a471d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e1ec57c7c0401dbee987d1c760ced7"><td class="memItemLeft" align="right" valign="top"><a id="ac1e1ec57c7c0401dbee987d1c760ced7"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>getNumberThreads</b> () const</td></tr>
<tr class="separator:ac1e1ec57c7c0401dbee987d1c760ced7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7d5f16ca53367feabc00b9efa05be8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a6f7d5f16ca53367feabc00b9efa05be8">getUidList</a> () const</td></tr>
<tr class="memdesc:a6f7d5f16ca53367feabc00b9efa05be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns vector containing unique ids of all cells.  <a href="#a6f7d5f16ca53367feabc00b9efa05be8">More...</a><br /></td></tr>
<tr class="separator:a6f7d5f16ca53367feabc00b9efa05be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d225e23c6a454058a3df5b7b5973fa"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#aa0d225e23c6a454058a3df5b7b5973fa">getBoundaryThickness</a> ()</td></tr>
<tr class="memdesc:aa0d225e23c6a454058a3df5b7b5973fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns boundary thickness of the domain, ie. the number of layers of cells outside the computed domain.  <a href="#aa0d225e23c6a454058a3df5b7b5973fa">More...</a><br /></td></tr>
<tr class="separator:aa0d225e23c6a454058a3df5b7b5973fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e2005bed3aa17f036b8d2b36084153"><td class="memItemLeft" align="right" valign="top">std::pair&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a29e2005bed3aa17f036b8d2b36084153">getBLOfSDD</a> (unsigned int SDDid) const</td></tr>
<tr class="memdesc:a29e2005bed3aa17f036b8d2b36084153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets bottom-left coordinates of SDD given by its id.  <a href="#a29e2005bed3aa17f036b8d2b36084153">More...</a><br /></td></tr>
<tr class="separator:a29e2005bed3aa17f036b8d2b36084153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2f7ee9336c682d4d6b01893d0beb4f"><td class="memItemLeft" align="right" valign="top">std::pair&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a1d2f7ee9336c682d4d6b01893d0beb4f">getCoordsOnDomain</a> (unsigned int uid) const</td></tr>
<tr class="memdesc:a1d2f7ee9336c682d4d6b01893d0beb4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets coordinates on computed domain of cell given by its unique id.  <a href="#a1d2f7ee9336c682d4d6b01893d0beb4f">More...</a><br /></td></tr>
<tr class="separator:a1d2f7ee9336c682d4d6b01893d0beb4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f219d1f46645da98f538dada37432f9"><td class="memItemLeft" align="right" valign="top">std::pair&lt; char, real &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a1f219d1f46645da98f538dada37432f9">getBoundaryCondition</a> (std::pair&lt; int, int &gt; coordsOnSDD) const</td></tr>
<tr class="memdesc:a1f219d1f46645da98f538dada37432f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns boundary condition on a cell given by its coordinates on the domain.  <a href="#a1f219d1f46645da98f538dada37432f9">More...</a><br /></td></tr>
<tr class="separator:a1f219d1f46645da98f538dada37432f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657f0b6750e14d1d3cde6afd8b1e9b48"><td class="memItemLeft" align="right" valign="top"><a id="a657f0b6750e14d1d3cde6afd8b1e9b48"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a657f0b6750e14d1d3cde6afd8b1e9b48">getUid</a> (std::pair&lt; int, int &gt; coordsOnDomain) const</td></tr>
<tr class="memdesc:a657f0b6750e14d1d3cde6afd8b1e9b48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-modifiable unique id of cell given by its coordinates on the domain. <br /></td></tr>
<tr class="separator:a657f0b6750e14d1d3cde6afd8b1e9b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677ba729e74d00b167b51ab6c921782a"><td class="memItemLeft" align="right" valign="top"><a id="a677ba729e74d00b167b51ab6c921782a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a677ba729e74d00b167b51ab6c921782a">getBoundarySide</a> (std::pair&lt; int, int &gt; coords) const</td></tr>
<tr class="memdesc:a677ba729e74d00b167b51ab6c921782a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns boundary side (left, right, top, bottom or inside if not on boundary) of a cell given by its coordinates on the domain. <br /></td></tr>
<tr class="separator:a677ba729e74d00b167b51ab6c921782a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1463e043dbcda6e6755dda83c26d6b73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a1463e043dbcda6e6755dda83c26d6b73">addCoord</a> (unsigned int uid, std::pair&lt; int, int &gt; coords)</td></tr>
<tr class="memdesc:a1463e043dbcda6e6755dda83c26d6b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds new unique id &lt;-&gt; coords on domain correspondence on a given cell.  <a href="#a1463e043dbcda6e6755dda83c26d6b73">More...</a><br /></td></tr>
<tr class="separator:a1463e043dbcda6e6755dda83c26d6b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139f4270151467a3380922e98c644f79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a139f4270151467a3380922e98c644f79">addBoundaryCoords</a> (unsigned int uid, std::pair&lt; int, int &gt; coords, char BCtype, real value)</td></tr>
<tr class="memdesc:a139f4270151467a3380922e98c644f79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds new unique id &lt;-&gt; coords on domain correspondencPieśnie and boundary condition for a cell on the boundary.  <a href="#a139f4270151467a3380922e98c644f79">More...</a><br /></td></tr>
<tr class="separator:a139f4270151467a3380922e98c644f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bad9ce1ce7d7fc7ef5b564bd5ac21e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a4bad9ce1ce7d7fc7ef5b564bd5ac21e1">addQuantity</a> (std::string quantityName, bool constant=false)</td></tr>
<tr class="memdesc:a4bad9ce1ce7d7fc7ef5b564bd5ac21e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds new quantity to be managed by the scheme.  <a href="#a4bad9ce1ce7d7fc7ef5b564bd5ac21e1">More...</a><br /></td></tr>
<tr class="separator:a4bad9ce1ce7d7fc7ef5b564bd5ac21e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be46362fe91960104764d9eb89f1d29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a3be46362fe91960104764d9eb89f1d29">addEquation</a> (std::string eqName, eqType eqFunc)</td></tr>
<tr class="memdesc:a3be46362fe91960104764d9eb89f1d29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds function that resolves a new equation on a SDS to be computed for each iteration by the domain.  <a href="#a3be46362fe91960104764d9eb89f1d29">More...</a><br /></td></tr>
<tr class="separator:a3be46362fe91960104764d9eb89f1d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1262b85d13fbbf90388e453d9602372"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#af1262b85d13fbbf90388e453d9602372">buildSubDomainsMPI</a> ()</td></tr>
<tr class="memdesc:af1262b85d13fbbf90388e453d9602372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds subdomains according to set options.  <a href="#af1262b85d13fbbf90388e453d9602372">More...</a><br /></td></tr>
<tr class="separator:af1262b85d13fbbf90388e453d9602372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1ecd27481f6c7c0b077225fa48bc99"><td class="memItemLeft" align="right" valign="top"><a id="a4d1ecd27481f6c7c0b077225fa48bc99"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a4d1ecd27481f6c7c0b077225fa48bc99">buildBoundaryMap</a> ()</td></tr>
<tr class="memdesc:a4d1ecd27481f6c7c0b077225fa48bc99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds all info needed by the domain to compute the boundary according to the boundary conditions set on boundary cells. <br /></td></tr>
<tr class="separator:a4d1ecd27481f6c7c0b077225fa48bc99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e6cebf44a57323f3c6344d131126c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#aa2e6cebf44a57323f3c6344d131126c1">buildThreads</a> ()</td></tr>
<tr class="memdesc:aa2e6cebf44a57323f3c6344d131126c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds the task pool for each SDD.  <a href="#aa2e6cebf44a57323f3c6344d131126c1">More...</a><br /></td></tr>
<tr class="separator:aa2e6cebf44a57323f3c6344d131126c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f3b3d25cb0a864f0c3e380cb9044be"><td class="memItemLeft" align="right" valign="top"><a id="a25f3b3d25cb0a864f0c3e380cb9044be"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a25f3b3d25cb0a864f0c3e380cb9044be">execEquation</a> (std::string eqName)</td></tr>
<tr class="memdesc:a25f3b3d25cb0a864f0c3e380cb9044be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls all added equations, ie. computes an iteration of the scheme on the domain. <br /></td></tr>
<tr class="separator:a25f3b3d25cb0a864f0c3e380cb9044be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4411f8eb6c118c84f16d62a411b4432a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a4411f8eb6c118c84f16d62a411b4432a">updateOverlapCells</a> ()</td></tr>
<tr class="memdesc:a4411f8eb6c118c84f16d62a411b4432a"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates overlap cells of all SDDs according to their values on reference cells on other SDDs, for a given quantity.  <a href="#a4411f8eb6c118c84f16d62a411b4432a">More...</a><br /></td></tr>
<tr class="separator:a4411f8eb6c118c84f16d62a411b4432a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e6670e39e3a6265ee57baeb70aa8867"><td class="memItemLeft" align="right" valign="top"><a id="a3e6670e39e3a6265ee57baeb70aa8867"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>updateOverlapCells</b> (std::string qtyName)</td></tr>
<tr class="separator:a3e6670e39e3a6265ee57baeb70aa8867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af169473470489edc4235399887c10da0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#af169473470489edc4235399887c10da0">updateBoundaryCells</a> (std::string quantityName, bool changeNeumannToOpposite=false)</td></tr>
<tr class="memdesc:af169473470489edc4235399887c10da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates boundary of all SDDs according to their values on reference cells on other SDDs, for a given quantity.  <a href="#af169473470489edc4235399887c10da0">More...</a><br /></td></tr>
<tr class="separator:af169473470489edc4235399887c10da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3fd7cbe29576ea63219b326c15680e"><td class="memItemLeft" align="right" valign="top">std::pair&lt; int, std::pair&lt; int, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a5b3fd7cbe29576ea63219b326c15680e">getSDDandCoords</a> (std::pair&lt; int, int &gt; coordsOnDomain) const</td></tr>
<tr class="memdesc:a5b3fd7cbe29576ea63219b326c15680e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-modifiable id of SDD and coordinates on SDD of cell given by its coordinates on the domain.  <a href="#a5b3fd7cbe29576ea63219b326c15680e">More...</a><br /></td></tr>
<tr class="separator:a5b3fd7cbe29576ea63219b326c15680e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6442039d5c64b9a59b7a1bd94fc6bbb"><td class="memItemLeft" align="right" valign="top">std::pair&lt; int, std::pair&lt; int, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#af6442039d5c64b9a59b7a1bd94fc6bbb">getSDDandCoords</a> (unsigned int SDDid, std::pair&lt; int, int &gt; coords) const</td></tr>
<tr class="memdesc:af6442039d5c64b9a59b7a1bd94fc6bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-modifiable id of SDD and coordinates on SDD of cell given by its coordinates on the domain.  <a href="#af6442039d5c64b9a59b7a1bd94fc6bbb">More...</a><br /></td></tr>
<tr class="separator:af6442039d5c64b9a59b7a1bd94fc6bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1163559d75540c4cd29c7aa775feca80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a1163559d75540c4cd29c7aa775feca80">printState</a> (std::string quantityName)</td></tr>
<tr class="memdesc:a1163559d75540c4cd29c7aa775feca80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints quantity values for all cells.  <a href="#a1163559d75540c4cd29c7aa775feca80">More...</a><br /></td></tr>
<tr class="separator:a1163559d75540c4cd29c7aa775feca80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1225a3c5e6e2a808c88d187adc7d3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#acc1225a3c5e6e2a808c88d187adc7d3c">setSDDInfo</a> (unsigned int BL_X, unsigned int BL_Y, unsigned int Nx, unsigned int Ny)</td></tr>
<tr class="memdesc:acc1225a3c5e6e2a808c88d187adc7d3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change characteristics of SDD (bottom-left and size)  <a href="#acc1225a3c5e6e2a808c88d187adc7d3c">More...</a><br /></td></tr>
<tr class="separator:acc1225a3c5e6e2a808c88d187adc7d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ceb37145bc70b3cc85e15e24a54287"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDDistributed.html">SDDistributed</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a26ceb37145bc70b3cc85e15e24a54287">getSDD</a> ()</td></tr>
<tr class="memdesc:a26ceb37145bc70b3cc85e15e24a54287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to SDD possessed by this MPI node.  <a href="#a26ceb37145bc70b3cc85e15e24a54287">More...</a><br /></td></tr>
<tr class="separator:a26ceb37145bc70b3cc85e15e24a54287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8172470afa3d3ec4c7202c8ee25ab3b8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSDDistributed.html">SDDistributed</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a8172470afa3d3ec4c7202c8ee25ab3b8">getSDDconst</a> () const</td></tr>
<tr class="memdesc:a8172470afa3d3ec4c7202c8ee25ab3b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to SDD possessed by this MPI node.  <a href="#a8172470afa3d3ec4c7202c8ee25ab3b8">More...</a><br /></td></tr>
<tr class="separator:a8172470afa3d3ec4c7202c8ee25ab3b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f12ce216ba0fdb5e46147875f9a97a3"><td class="memItemLeft" align="right" valign="top"><a id="a9f12ce216ba0fdb5e46147875f9a97a3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>switchQuantityPrevNext</b> (std::string quantityName)</td></tr>
<tr class="separator:a9f12ce216ba0fdb5e46147875f9a97a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6adccae537e53d4fde2b70f875e6b8d0"><td class="memItemLeft" align="right" valign="top"><a id="a6adccae537e53d4fde2b70f875e6b8d0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a6adccae537e53d4fde2b70f875e6b8d0">Domain</a> ()</td></tr>
<tr class="memdesc:a6adccae537e53d4fde2b70f875e6b8d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a6adccae537e53d4fde2b70f875e6b8d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29cec9afb2e54c810ba1f3c1a49543a8"><td class="memItemLeft" align="right" valign="top"><a id="a29cec9afb2e54c810ba1f3c1a49543a8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a29cec9afb2e54c810ba1f3c1a49543a8">~Domain</a> ()</td></tr>
<tr class="memdesc:a29cec9afb2e54c810ba1f3c1a49543a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a29cec9afb2e54c810ba1f3c1a49543a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853266061b629ff1f920b46c06c478d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a853266061b629ff1f920b46c06c478d6">initRect</a> (real lx, real ly, unsigned int Nx, unsigned int Ny)</td></tr>
<tr class="memdesc:a853266061b629ff1f920b46c06c478d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes domain rectangle.  <a href="#a853266061b629ff1f920b46c06c478d6">More...</a><br /></td></tr>
<tr class="separator:a853266061b629ff1f920b46c06c478d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a5e8384b21bb3c968699c2a6c89bf7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a10a5e8384b21bb3c968699c2a6c89bf7">setOptions</a> (unsigned int nSDD, unsigned int nSDD_X, unsigned int nSDD_Y, unsigned int nSDS, std::string SDSgeom, unsigned int nThreads)</td></tr>
<tr class="memdesc:a10a5e8384b21bb3c968699c2a6c89bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes options for building SDDs and SDSs.  <a href="#a10a5e8384b21bb3c968699c2a6c89bf7">More...</a><br /></td></tr>
<tr class="separator:a10a5e8384b21bb3c968699c2a6c89bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae560ad14f723c01663bbb783ede30fd8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classSDDistributed.html">SDDistributed</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#ae560ad14f723c01663bbb783ede30fd8">getSDD</a> () const</td></tr>
<tr class="memdesc:ae560ad14f723c01663bbb783ede30fd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns vector of pointers to SDDs of the domain.  <a href="#ae560ad14f723c01663bbb783ede30fd8">More...</a><br /></td></tr>
<tr class="separator:ae560ad14f723c01663bbb783ede30fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a510afad91fe81eb2ccef203a980f4223"><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a510afad91fe81eb2ccef203a980f4223">getlx</a> () const</td></tr>
<tr class="memdesc:a510afad91fe81eb2ccef203a980f4223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the non-modifiable width of the domain.  <a href="#a510afad91fe81eb2ccef203a980f4223">More...</a><br /></td></tr>
<tr class="separator:a510afad91fe81eb2ccef203a980f4223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9cedab179bb0611fc0e9fcfbcedb835"><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#ac9cedab179bb0611fc0e9fcfbcedb835">getly</a> () const</td></tr>
<tr class="memdesc:ac9cedab179bb0611fc0e9fcfbcedb835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the non-modifiable height of the domain.  <a href="#ac9cedab179bb0611fc0e9fcfbcedb835">More...</a><br /></td></tr>
<tr class="separator:ac9cedab179bb0611fc0e9fcfbcedb835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f299e3871fe9cec01637b140429ef9"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a75f299e3871fe9cec01637b140429ef9">getSizeX</a> () const</td></tr>
<tr class="memdesc:a75f299e3871fe9cec01637b140429ef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the non-modifiable number of cells on the x-axis.  <a href="#a75f299e3871fe9cec01637b140429ef9">More...</a><br /></td></tr>
<tr class="separator:a75f299e3871fe9cec01637b140429ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66692b4f23353c9b1fe884e583770cb3"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a66692b4f23353c9b1fe884e583770cb3">getSizeY</a> () const</td></tr>
<tr class="memdesc:a66692b4f23353c9b1fe884e583770cb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the non-modifiable number of cells on the y-axis.  <a href="#a66692b4f23353c9b1fe884e583770cb3">More...</a><br /></td></tr>
<tr class="separator:a66692b4f23353c9b1fe884e583770cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb586f6ef994a1621680ec9b946aeb4"><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#acdb586f6ef994a1621680ec9b946aeb4">getdx</a> () const</td></tr>
<tr class="memdesc:acdb586f6ef994a1621680ec9b946aeb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the non-modifiable space step on the x-axis (ie. the width of a cell).  <a href="#acdb586f6ef994a1621680ec9b946aeb4">More...</a><br /></td></tr>
<tr class="separator:acdb586f6ef994a1621680ec9b946aeb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e62ab8a8b53f67cc3c30b6066b10aac"><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a5e62ab8a8b53f67cc3c30b6066b10aac">getdy</a> () const</td></tr>
<tr class="memdesc:a5e62ab8a8b53f67cc3c30b6066b10aac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the non-modifiable space step on the y-axis (ie. the height of a cell).  <a href="#a5e62ab8a8b53f67cc3c30b6066b10aac">More...</a><br /></td></tr>
<tr class="separator:a5e62ab8a8b53f67cc3c30b6066b10aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc1ec9b45f0430fa4bb8c7d3eb8d9f4"><td class="memItemLeft" align="right" valign="top"><a id="accc1ec9b45f0430fa4bb8c7d3eb8d9f4"></a>
std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#accc1ec9b45f0430fa4bb8c7d3eb8d9f4">getUidList</a> () const</td></tr>
<tr class="memdesc:accc1ec9b45f0430fa4bb8c7d3eb8d9f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns vector containing unique ids of all cells. <br /></td></tr>
<tr class="separator:accc1ec9b45f0430fa4bb8c7d3eb8d9f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b780bfe072c70ac437f0f31f10d5c4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#af3b780bfe072c70ac437f0f31f10d5c4">getBoundaryUidList</a> () const</td></tr>
<tr class="memdesc:af3b780bfe072c70ac437f0f31f10d5c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns vector containing unique ids of all cells outside of the computed domain, ie. on the boundary.  <a href="#af3b780bfe072c70ac437f0f31f10d5c4">More...</a><br /></td></tr>
<tr class="separator:af3b780bfe072c70ac437f0f31f10d5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d225e23c6a454058a3df5b7b5973fa"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#aa0d225e23c6a454058a3df5b7b5973fa">getBoundaryThickness</a> ()</td></tr>
<tr class="memdesc:aa0d225e23c6a454058a3df5b7b5973fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns boundary thickness of the domain, ie. the number of layers of cells outside the computed domain.  <a href="#aa0d225e23c6a454058a3df5b7b5973fa">More...</a><br /></td></tr>
<tr class="separator:aa0d225e23c6a454058a3df5b7b5973fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad99f85d4d30525bac3ac258a0032bdf7"><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#ad99f85d4d30525bac3ac258a0032bdf7">getValue</a> (std::string quantityName, unsigned int uid, int onNext=0) const</td></tr>
<tr class="memdesc:ad99f85d4d30525bac3ac258a0032bdf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-modifiable quantity value of a cell given by its id.  <a href="#ad99f85d4d30525bac3ac258a0032bdf7">More...</a><br /></td></tr>
<tr class="separator:ad99f85d4d30525bac3ac258a0032bdf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9319e738fbd4ada8145998d5392c9334"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a9319e738fbd4ada8145998d5392c9334">setValue</a> (std::string quantityName, unsigned int uid, real value, int onNext=0)</td></tr>
<tr class="memdesc:a9319e738fbd4ada8145998d5392c9334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies quantity value of a cell given by its id.  <a href="#a9319e738fbd4ada8145998d5392c9334">More...</a><br /></td></tr>
<tr class="separator:a9319e738fbd4ada8145998d5392c9334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd93464e05e2a631f01cc30277db885"><td class="memItemLeft" align="right" valign="top">std::pair&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a9dd93464e05e2a631f01cc30277db885">getBLOfSDD</a> (unsigned int SDDid) const</td></tr>
<tr class="memdesc:a9dd93464e05e2a631f01cc30277db885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets bottom-left coordinates of SDD given by its id.  <a href="#a9dd93464e05e2a631f01cc30277db885">More...</a><br /></td></tr>
<tr class="separator:a9dd93464e05e2a631f01cc30277db885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eba31dcda6d3a45f41a3839a34706c8"><td class="memItemLeft" align="right" valign="top">std::pair&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a7eba31dcda6d3a45f41a3839a34706c8">getCoordsOnDomain</a> (unsigned int uid) const</td></tr>
<tr class="memdesc:a7eba31dcda6d3a45f41a3839a34706c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets coordinates on computed domain of cell given by its unique id.  <a href="#a7eba31dcda6d3a45f41a3839a34706c8">More...</a><br /></td></tr>
<tr class="separator:a7eba31dcda6d3a45f41a3839a34706c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a893851a7caff52261beb79888d46be1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSDDistributed.html">SDDistributed</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a893851a7caff52261beb79888d46be1f">getSDDforCoords</a> (std::pair&lt; int, int &gt; coordsOnDomain)</td></tr>
<tr class="memdesc:a893851a7caff52261beb79888d46be1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets pointer to SDD in charge of the computation of a cell given by its coordinates on the domain.  <a href="#a893851a7caff52261beb79888d46be1f">More...</a><br /></td></tr>
<tr class="separator:a893851a7caff52261beb79888d46be1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23641933f63bd9b7ff51ee67791823b4"><td class="memItemLeft" align="right" valign="top">std::pair&lt; char, real &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a23641933f63bd9b7ff51ee67791823b4">getBoundaryCondition</a> (unsigned int uid) const</td></tr>
<tr class="memdesc:a23641933f63bd9b7ff51ee67791823b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns boundary condition on a cell given by its uid.  <a href="#a23641933f63bd9b7ff51ee67791823b4">More...</a><br /></td></tr>
<tr class="separator:a23641933f63bd9b7ff51ee67791823b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb1110620465fc735aac4f37962fbf3d"><td class="memItemLeft" align="right" valign="top">std::pair&lt; char, real &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#aeb1110620465fc735aac4f37962fbf3d">getBoundaryCondition</a> (std::pair&lt; int, int &gt; coords) const</td></tr>
<tr class="memdesc:aeb1110620465fc735aac4f37962fbf3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns boundary condition on a cell given by its coordinates on the domain.  <a href="#aeb1110620465fc735aac4f37962fbf3d">More...</a><br /></td></tr>
<tr class="separator:aeb1110620465fc735aac4f37962fbf3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657f0b6750e14d1d3cde6afd8b1e9b48"><td class="memItemLeft" align="right" valign="top"><a id="a657f0b6750e14d1d3cde6afd8b1e9b48"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a657f0b6750e14d1d3cde6afd8b1e9b48">getUid</a> (std::pair&lt; int, int &gt; coordsOnDomain) const</td></tr>
<tr class="memdesc:a657f0b6750e14d1d3cde6afd8b1e9b48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-modifiable unique id of cell given by its coordinates on the domain. <br /></td></tr>
<tr class="separator:a657f0b6750e14d1d3cde6afd8b1e9b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677ba729e74d00b167b51ab6c921782a"><td class="memItemLeft" align="right" valign="top"><a id="a677ba729e74d00b167b51ab6c921782a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a677ba729e74d00b167b51ab6c921782a">getBoundarySide</a> (std::pair&lt; int, int &gt; coords) const</td></tr>
<tr class="memdesc:a677ba729e74d00b167b51ab6c921782a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns boundary side (left, right, top, bottom or inside if not on boundary) of a cell given by its coordinates on the domain. <br /></td></tr>
<tr class="separator:a677ba729e74d00b167b51ab6c921782a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1463e043dbcda6e6755dda83c26d6b73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a1463e043dbcda6e6755dda83c26d6b73">addCoord</a> (unsigned int uid, std::pair&lt; int, int &gt; coords)</td></tr>
<tr class="memdesc:a1463e043dbcda6e6755dda83c26d6b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds new unique id &lt;-&gt; coords on domain correspondence on a given cell.  <a href="#a1463e043dbcda6e6755dda83c26d6b73">More...</a><br /></td></tr>
<tr class="separator:a1463e043dbcda6e6755dda83c26d6b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139f4270151467a3380922e98c644f79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a139f4270151467a3380922e98c644f79">addBoundaryCoords</a> (unsigned int uid, std::pair&lt; int, int &gt; coords, char BCtype, real value)</td></tr>
<tr class="memdesc:a139f4270151467a3380922e98c644f79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds new unique id &lt;-&gt; coords on domain correspondencPieśnie and boundary condition for a cell on the boundary.  <a href="#a139f4270151467a3380922e98c644f79">More...</a><br /></td></tr>
<tr class="separator:a139f4270151467a3380922e98c644f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c33ac08523c95967ad2a51c59fd8d96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a9c33ac08523c95967ad2a51c59fd8d96">addQuantity</a> (std::string quantityName)</td></tr>
<tr class="memdesc:a9c33ac08523c95967ad2a51c59fd8d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds new quantity to be managed by the scheme.  <a href="#a9c33ac08523c95967ad2a51c59fd8d96">More...</a><br /></td></tr>
<tr class="separator:a9c33ac08523c95967ad2a51c59fd8d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24a61d835dbebec7ff689ec8c7f2a95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#ab24a61d835dbebec7ff689ec8c7f2a95">addEquation</a> (eqType eqFunc)</td></tr>
<tr class="memdesc:ab24a61d835dbebec7ff689ec8c7f2a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds function that resolves a new equation on a SDS to be computed for each iteration by the domain.  <a href="#ab24a61d835dbebec7ff689ec8c7f2a95">More...</a><br /></td></tr>
<tr class="separator:ab24a61d835dbebec7ff689ec8c7f2a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29537b651bacd922cae449357969d900"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a29537b651bacd922cae449357969d900">buildSubDomains</a> ()</td></tr>
<tr class="memdesc:a29537b651bacd922cae449357969d900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds subdomains according to set options.  <a href="#a29537b651bacd922cae449357969d900">More...</a><br /></td></tr>
<tr class="separator:a29537b651bacd922cae449357969d900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1ecd27481f6c7c0b077225fa48bc99"><td class="memItemLeft" align="right" valign="top"><a id="a4d1ecd27481f6c7c0b077225fa48bc99"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a4d1ecd27481f6c7c0b077225fa48bc99">buildBoundaryMap</a> ()</td></tr>
<tr class="memdesc:a4d1ecd27481f6c7c0b077225fa48bc99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds all info needed by the domain to compute the boundary according to the boundary conditions set on boundary cells. <br /></td></tr>
<tr class="separator:a4d1ecd27481f6c7c0b077225fa48bc99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e6cebf44a57323f3c6344d131126c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#aa2e6cebf44a57323f3c6344d131126c1">buildThreads</a> ()</td></tr>
<tr class="memdesc:aa2e6cebf44a57323f3c6344d131126c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds the task pool for each SDD.  <a href="#aa2e6cebf44a57323f3c6344d131126c1">More...</a><br /></td></tr>
<tr class="separator:aa2e6cebf44a57323f3c6344d131126c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae587a47610505c21fdd32a9f82d70402"><td class="memItemLeft" align="right" valign="top"><a id="ae587a47610505c21fdd32a9f82d70402"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#ae587a47610505c21fdd32a9f82d70402">execEquation</a> ()</td></tr>
<tr class="memdesc:ae587a47610505c21fdd32a9f82d70402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls all added equations, ie. computes an iteration of the scheme on the domain. <br /></td></tr>
<tr class="separator:ae587a47610505c21fdd32a9f82d70402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd8aa2529907b8022e41e45c85f5144"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#abcd8aa2529907b8022e41e45c85f5144">updateOverlapCells</a> (std::string quantityName)</td></tr>
<tr class="memdesc:abcd8aa2529907b8022e41e45c85f5144"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates overlap cells of all SDDs according to their values on reference cells on other SDDs, for a given quantity.  <a href="#abcd8aa2529907b8022e41e45c85f5144">More...</a><br /></td></tr>
<tr class="separator:abcd8aa2529907b8022e41e45c85f5144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af169473470489edc4235399887c10da0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#af169473470489edc4235399887c10da0">updateBoundaryCells</a> (std::string quantityName, bool changeNeumannToOpposite=false)</td></tr>
<tr class="memdesc:af169473470489edc4235399887c10da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates boundary of all SDDs according to their values on reference cells on other SDDs, for a given quantity.  <a href="#af169473470489edc4235399887c10da0">More...</a><br /></td></tr>
<tr class="separator:af169473470489edc4235399887c10da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a155bbf1a1abd44c98cf78c090259b5a4"><td class="memItemLeft" align="right" valign="top">std::pair&lt; int, std::pair&lt; int, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a155bbf1a1abd44c98cf78c090259b5a4">getSDDandCoords</a> (std::pair&lt; int, int &gt; coordsOnDomain) const</td></tr>
<tr class="memdesc:a155bbf1a1abd44c98cf78c090259b5a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-modifiable id of SDD and coordinates on SDD of cell given by its coordinates on the domain.  <a href="#a155bbf1a1abd44c98cf78c090259b5a4">More...</a><br /></td></tr>
<tr class="separator:a155bbf1a1abd44c98cf78c090259b5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777cc4eed9570aea2477ef41f26566ff"><td class="memItemLeft" align="right" valign="top">std::pair&lt; int, std::pair&lt; int, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a777cc4eed9570aea2477ef41f26566ff">getSDDandCoords</a> (unsigned int SDDid, std::pair&lt; int, int &gt; coords) const</td></tr>
<tr class="memdesc:a777cc4eed9570aea2477ef41f26566ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-modifiable id of SDD and coordinates on SDD of cell given by its coordinates on the domain.  <a href="#a777cc4eed9570aea2477ef41f26566ff">More...</a><br /></td></tr>
<tr class="separator:a777cc4eed9570aea2477ef41f26566ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1163559d75540c4cd29c7aa775feca80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html#a1163559d75540c4cd29c7aa775feca80">printState</a> (std::string quantityName)</td></tr>
<tr class="memdesc:a1163559d75540c4cd29c7aa775feca80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints quantity values for all cells.  <a href="#a1163559d75540c4cd29c7aa775feca80">More...</a><br /></td></tr>
<tr class="separator:a1163559d75540c4cd29c7aa775feca80"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classDomain.html" title="Domain on which a scheme is executed. ">Domain</a> on which a scheme is executed. </p>
<p>A domain is the physical discrete set on which a finite volumes scheme is solved. Its space is divided into subdomains on distributed memory (SDD), in order to allow MPI parallel execution on several machines. These subdomains are then split in smaller subdomains (SDS), each one being treated as a task assigned to a thread. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a139f4270151467a3380922e98c644f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a139f4270151467a3380922e98c644f79">&#9670;&nbsp;</a></span>addBoundaryCoords() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Domain::addBoundaryCoords </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>uid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; int, int &gt;&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>BCtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds new unique id &lt;-&gt; coords on domain correspondencPieśnie and boundary condition for a cell on the boundary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uid</td><td>unique id of new cell </td></tr>
    <tr><td class="paramname">coords</td><td>coordinates of new cell on the domain </td></tr>
    <tr><td class="paramname">BCtype</td><td>boundary condition type </td></tr>
    <tr><td class="paramname">value</td><td>boundary condition value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a139f4270151467a3380922e98c644f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a139f4270151467a3380922e98c644f79">&#9670;&nbsp;</a></span>addBoundaryCoords() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Domain::addBoundaryCoords </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>uid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; int, int &gt;&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>BCtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds new unique id &lt;-&gt; coords on domain correspondencPieśnie and boundary condition for a cell on the boundary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uid</td><td>unique id of new cell </td></tr>
    <tr><td class="paramname">coords</td><td>coordinates of new cell on the domain </td></tr>
    <tr><td class="paramname">BCtype</td><td>boundary condition type </td></tr>
    <tr><td class="paramname">value</td><td>boundary condition value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1463e043dbcda6e6755dda83c26d6b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1463e043dbcda6e6755dda83c26d6b73">&#9670;&nbsp;</a></span>addCoord() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Domain::addCoord </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>uid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; int, int &gt;&#160;</td>
          <td class="paramname"><em>coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds new unique id &lt;-&gt; coords on domain correspondence on a given cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uid</td><td>unique id of new cell </td></tr>
    <tr><td class="paramname">coords</td><td>coordinates of new cell on the domain </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1463e043dbcda6e6755dda83c26d6b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1463e043dbcda6e6755dda83c26d6b73">&#9670;&nbsp;</a></span>addCoord() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Domain::addCoord </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>uid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; int, int &gt;&#160;</td>
          <td class="paramname"><em>coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds new unique id &lt;-&gt; coords on domain correspondence on a given cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uid</td><td>unique id of new cell </td></tr>
    <tr><td class="paramname">coords</td><td>coordinates of new cell on the domain </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3be46362fe91960104764d9eb89f1d29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be46362fe91960104764d9eb89f1d29">&#9670;&nbsp;</a></span>addEquation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Domain::addEquation </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>eqName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">eqType&#160;</td>
          <td class="paramname"><em>eqFunc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds function that resolves a new equation on a SDS to be computed for each iteration by the domain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">equation</td><td>function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab24a61d835dbebec7ff689ec8c7f2a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab24a61d835dbebec7ff689ec8c7f2a95">&#9670;&nbsp;</a></span>addEquation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Domain::addEquation </td>
          <td>(</td>
          <td class="paramtype">eqType&#160;</td>
          <td class="paramname"><em>eqFunc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds function that resolves a new equation on a SDS to be computed for each iteration by the domain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">equation</td><td>function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4bad9ce1ce7d7fc7ef5b564bd5ac21e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bad9ce1ce7d7fc7ef5b564bd5ac21e1">&#9670;&nbsp;</a></span>addQuantity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Domain::addQuantity </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>quantityName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>constant</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds new quantity to be managed by the scheme. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>of new quantity </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c33ac08523c95967ad2a51c59fd8d96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c33ac08523c95967ad2a51c59fd8d96">&#9670;&nbsp;</a></span>addQuantity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Domain::addQuantity </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>quantityName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds new quantity to be managed by the scheme. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>of new quantity </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29537b651bacd922cae449357969d900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29537b651bacd922cae449357969d900">&#9670;&nbsp;</a></span>buildSubDomains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Domain::buildSubDomains </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds subdomains according to set options. </p>
<p>This creates the SDDs and their SDSs according to options set in function setOptions, that has to be called before calling this function. </p>

</div>
</div>
<a id="af1262b85d13fbbf90388e453d9602372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1262b85d13fbbf90388e453d9602372">&#9670;&nbsp;</a></span>buildSubDomainsMPI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Domain::buildSubDomainsMPI </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds subdomains according to set options. </p>
<p>This creates the SDDs and their SDSs according to options set in function setOptions, that has to be called before calling this function. </p>

</div>
</div>
<a id="aa2e6cebf44a57323f3c6344d131126c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e6cebf44a57323f3c6344d131126c1">&#9670;&nbsp;</a></span>buildThreads() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Domain::buildThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds the task pool for each SDD. </p>
<p>This can only be called after options were set and subdomains were built. </p>

</div>
</div>
<a id="aa2e6cebf44a57323f3c6344d131126c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e6cebf44a57323f3c6344d131126c1">&#9670;&nbsp;</a></span>buildThreads() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Domain::buildThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds the task pool for each SDD. </p>
<p>This can only be called after options were set and subdomains were built. </p>

</div>
</div>
<a id="a29e2005bed3aa17f036b8d2b36084153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29e2005bed3aa17f036b8d2b36084153">&#9670;&nbsp;</a></span>getBLOfSDD() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int, int &gt; Domain::getBLOfSDD </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>SDDid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets bottom-left coordinates of SDD given by its id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SSDid</td><td>id of desired SDD, with <img class="formulaInl" alt="$0 \leq \texttt{SDDid} &lt; \texttt{nSDD}$" src="form_2.png"/></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>coordinates of bottom-left cell of desired SDD </dd></dl>

</div>
</div>
<a id="a9dd93464e05e2a631f01cc30277db885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dd93464e05e2a631f01cc30277db885">&#9670;&nbsp;</a></span>getBLOfSDD() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;int, int&gt; Domain::getBLOfSDD </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>SDDid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets bottom-left coordinates of SDD given by its id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SSDid</td><td>id of desired SDD, with <img class="formulaInl" alt="$0 \leq \texttt{SDDid} &lt; \texttt{nSDD}$" src="form_2.png"/></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>coordinates of bottom-left cell of desired SDD </dd></dl>

</div>
</div>
<a id="a1f219d1f46645da98f538dada37432f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f219d1f46645da98f538dada37432f9">&#9670;&nbsp;</a></span>getBoundaryCondition() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; char, real &gt; Domain::getBoundaryCondition </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; int, int &gt;&#160;</td>
          <td class="paramname"><em>coordsOnSDD</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns boundary condition on a cell given by its coordinates on the domain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coords</td><td>on the domain of desired cell</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boundary condition (type and value) assigned to cell </dd></dl>

</div>
</div>
<a id="a23641933f63bd9b7ff51ee67791823b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23641933f63bd9b7ff51ee67791823b4">&#9670;&nbsp;</a></span>getBoundaryCondition() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; char, real &gt; Domain::getBoundaryCondition </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>uid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns boundary condition on a cell given by its uid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uid</td><td>unique id of desired cell</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boundary condition (type and value) assigned to cell </dd></dl>

</div>
</div>
<a id="aeb1110620465fc735aac4f37962fbf3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb1110620465fc735aac4f37962fbf3d">&#9670;&nbsp;</a></span>getBoundaryCondition() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;char, real&gt; Domain::getBoundaryCondition </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; int, int &gt;&#160;</td>
          <td class="paramname"><em>coords</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns boundary condition on a cell given by its coordinates on the domain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coords</td><td>on the domain of desired cell</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boundary condition (type and value) assigned to cell </dd></dl>

</div>
</div>
<a id="aa0d225e23c6a454058a3df5b7b5973fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0d225e23c6a454058a3df5b7b5973fa">&#9670;&nbsp;</a></span>getBoundaryThickness() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Domain::getBoundaryThickness </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns boundary thickness of the domain, ie. the number of layers of cells outside the computed domain. </p>
<dl class="section return"><dt>Returns</dt><dd>boundary thickness </dd></dl>

</div>
</div>
<a id="aa0d225e23c6a454058a3df5b7b5973fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0d225e23c6a454058a3df5b7b5973fa">&#9670;&nbsp;</a></span>getBoundaryThickness() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Domain::getBoundaryThickness </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns boundary thickness of the domain, ie. the number of layers of cells outside the computed domain. </p>
<dl class="section return"><dt>Returns</dt><dd>boundary thickness </dd></dl>

</div>
</div>
<a id="af3b780bfe072c70ac437f0f31f10d5c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3b780bfe072c70ac437f0f31f10d5c4">&#9670;&nbsp;</a></span>getBoundaryUidList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned int &gt; Domain::getBoundaryUidList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns vector containing unique ids of all cells outside of the computed domain, ie. on the boundary. </p>
<dl class="section return"><dt>Returns</dt><dd>vector of unique ids of all cells on boundary </dd></dl>

</div>
</div>
<a id="a1d2f7ee9336c682d4d6b01893d0beb4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d2f7ee9336c682d4d6b01893d0beb4f">&#9670;&nbsp;</a></span>getCoordsOnDomain() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int, int &gt; Domain::getCoordsOnDomain </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>uid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets coordinates on computed domain of cell given by its unique id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uid</td><td>unique id of desired cell</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>coordinates on domain of desired cell </dd></dl>

</div>
</div>
<a id="a7eba31dcda6d3a45f41a3839a34706c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eba31dcda6d3a45f41a3839a34706c8">&#9670;&nbsp;</a></span>getCoordsOnDomain() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;int, int&gt; Domain::getCoordsOnDomain </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>uid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets coordinates on computed domain of cell given by its unique id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uid</td><td>unique id of desired cell</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>coordinates on domain of desired cell </dd></dl>

</div>
</div>
<a id="acdb586f6ef994a1621680ec9b946aeb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb586f6ef994a1621680ec9b946aeb4">&#9670;&nbsp;</a></span>getdx() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real Domain::getdx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the non-modifiable space step on the x-axis (ie. the width of a cell). </p>
<dl class="section return"><dt>Returns</dt><dd>space step on the x-axis </dd></dl>

</div>
</div>
<a id="acdb586f6ef994a1621680ec9b946aeb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb586f6ef994a1621680ec9b946aeb4">&#9670;&nbsp;</a></span>getdx() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real Domain::getdx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the non-modifiable space step on the x-axis (ie. the width of a cell). </p>
<dl class="section return"><dt>Returns</dt><dd>space step on the x-axis </dd></dl>

</div>
</div>
<a id="a5e62ab8a8b53f67cc3c30b6066b10aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e62ab8a8b53f67cc3c30b6066b10aac">&#9670;&nbsp;</a></span>getdy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real Domain::getdy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the non-modifiable space step on the y-axis (ie. the height of a cell). </p>
<dl class="section return"><dt>Returns</dt><dd>space step on the y-axis </dd></dl>

</div>
</div>
<a id="a5e62ab8a8b53f67cc3c30b6066b10aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e62ab8a8b53f67cc3c30b6066b10aac">&#9670;&nbsp;</a></span>getdy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real Domain::getdy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the non-modifiable space step on the y-axis (ie. the height of a cell). </p>
<dl class="section return"><dt>Returns</dt><dd>space step on the y-axis </dd></dl>

</div>
</div>
<a id="a510afad91fe81eb2ccef203a980f4223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a510afad91fe81eb2ccef203a980f4223">&#9670;&nbsp;</a></span>getlx() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real Domain::getlx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the non-modifiable width of the domain. </p>
<dl class="section return"><dt>Returns</dt><dd>width of the domain </dd></dl>

</div>
</div>
<a id="a510afad91fe81eb2ccef203a980f4223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a510afad91fe81eb2ccef203a980f4223">&#9670;&nbsp;</a></span>getlx() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real Domain::getlx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the non-modifiable width of the domain. </p>
<dl class="section return"><dt>Returns</dt><dd>width of the domain </dd></dl>

</div>
</div>
<a id="ac9cedab179bb0611fc0e9fcfbcedb835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9cedab179bb0611fc0e9fcfbcedb835">&#9670;&nbsp;</a></span>getly() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real Domain::getly </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the non-modifiable height of the domain. </p>
<dl class="section return"><dt>Returns</dt><dd>height of the domain </dd></dl>

</div>
</div>
<a id="ac9cedab179bb0611fc0e9fcfbcedb835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9cedab179bb0611fc0e9fcfbcedb835">&#9670;&nbsp;</a></span>getly() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real Domain::getly </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the non-modifiable height of the domain. </p>
<dl class="section return"><dt>Returns</dt><dd>height of the domain </dd></dl>

</div>
</div>
<a id="ae560ad14f723c01663bbb783ede30fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae560ad14f723c01663bbb783ede30fd8">&#9670;&nbsp;</a></span>getSDD() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classSDDistributed.html">SDDistributed</a> * &gt; Domain::getSDD </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns vector of pointers to SDDs of the domain. </p>
<dl class="section return"><dt>Returns</dt><dd>vector of pointers to SDDs of the domain. </dd></dl>

</div>
</div>
<a id="a26ceb37145bc70b3cc85e15e24a54287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26ceb37145bc70b3cc85e15e24a54287">&#9670;&nbsp;</a></span>getSDD() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDDistributed.html">SDDistributed</a> &amp; Domain::getSDD </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns reference to SDD possessed by this MPI node. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to SDD </dd></dl>

</div>
</div>
<a id="a5b3fd7cbe29576ea63219b326c15680e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b3fd7cbe29576ea63219b326c15680e">&#9670;&nbsp;</a></span>getSDDandCoords() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int, std::pair&lt; int, int &gt; &gt; Domain::getSDDandCoords </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; int, int &gt;&#160;</td>
          <td class="paramname"><em>coordsOnDomain</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns non-modifiable id of SDD and coordinates on SDD of cell given by its coordinates on the domain. </p>
<p>The returned SDD is the one that owns the cell on its computed area, ie. not as an overlap cell.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coordinates</td><td>of desired cell on domain</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>id of SDD and coordinates on SDD of desired cell </dd></dl>

</div>
</div>
<a id="af6442039d5c64b9a59b7a1bd94fc6bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6442039d5c64b9a59b7a1bd94fc6bbb">&#9670;&nbsp;</a></span>getSDDandCoords() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int, std::pair&lt; int, int &gt; &gt; Domain::getSDDandCoords </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>SDDid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; int, int &gt;&#160;</td>
          <td class="paramname"><em>coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns non-modifiable id of SDD and coordinates on SDD of cell given by its coordinates on the domain. </p>
<p>The returned SDD is the one that owns the cell on its computed area, ie. not as an overlap cell.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coordinates</td><td>of desired cell on domain</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>id of SDD and coordinates on SDD of desired cell </dd></dl>

</div>
</div>
<a id="a155bbf1a1abd44c98cf78c090259b5a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a155bbf1a1abd44c98cf78c090259b5a4">&#9670;&nbsp;</a></span>getSDDandCoords() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;int, std::pair&lt;int, int&gt; &gt; Domain::getSDDandCoords </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; int, int &gt;&#160;</td>
          <td class="paramname"><em>coordsOnDomain</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns non-modifiable id of SDD and coordinates on SDD of cell given by its coordinates on the domain. </p>
<p>The returned SDD is the one that owns the cell on its computed area, ie. not as an overlap cell.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coordinates</td><td>of desired cell on domain</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>id of SDD and coordinates on SDD of desired cell </dd></dl>

</div>
</div>
<a id="a777cc4eed9570aea2477ef41f26566ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a777cc4eed9570aea2477ef41f26566ff">&#9670;&nbsp;</a></span>getSDDandCoords() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;int, std::pair&lt;int, int&gt; &gt; Domain::getSDDandCoords </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>SDDid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; int, int &gt;&#160;</td>
          <td class="paramname"><em>coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns non-modifiable id of SDD and coordinates on SDD of cell given by its coordinates on the domain. </p>
<p>The returned SDD is the one that owns the cell on its computed area, ie. not as an overlap cell.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coordinates</td><td>of desired cell on domain</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>id of SDD and coordinates on SDD of desired cell </dd></dl>

</div>
</div>
<a id="a8172470afa3d3ec4c7202c8ee25ab3b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8172470afa3d3ec4c7202c8ee25ab3b8">&#9670;&nbsp;</a></span>getSDDconst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSDDistributed.html">SDDistributed</a> &amp; Domain::getSDDconst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns const reference to SDD possessed by this MPI node. </p>
<dl class="section return"><dt>Returns</dt><dd>const reference to SDD </dd></dl>

</div>
</div>
<a id="a893851a7caff52261beb79888d46be1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a893851a7caff52261beb79888d46be1f">&#9670;&nbsp;</a></span>getSDDforCoords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSDDistributed.html">SDDistributed</a> * Domain::getSDDforCoords </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; int, int &gt;&#160;</td>
          <td class="paramname"><em>coordsOnDomain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets pointer to SDD in charge of the computation of a cell given by its coordinates on the domain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coordsOnDomain</td><td>coordinates on the domain of the cell</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to SDD </dd></dl>

</div>
</div>
<a id="a75f299e3871fe9cec01637b140429ef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f299e3871fe9cec01637b140429ef9">&#9670;&nbsp;</a></span>getSizeX() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Domain::getSizeX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the non-modifiable number of cells on the x-axis. </p>
<dl class="section return"><dt>Returns</dt><dd>number of cells on x-axis </dd></dl>

</div>
</div>
<a id="a75f299e3871fe9cec01637b140429ef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f299e3871fe9cec01637b140429ef9">&#9670;&nbsp;</a></span>getSizeX() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Domain::getSizeX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the non-modifiable number of cells on the x-axis. </p>
<dl class="section return"><dt>Returns</dt><dd>number of cells on x-axis </dd></dl>

</div>
</div>
<a id="a66692b4f23353c9b1fe884e583770cb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66692b4f23353c9b1fe884e583770cb3">&#9670;&nbsp;</a></span>getSizeY() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Domain::getSizeY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the non-modifiable number of cells on the y-axis. </p>
<dl class="section return"><dt>Returns</dt><dd>number of cells on y-axis </dd></dl>

</div>
</div>
<a id="a66692b4f23353c9b1fe884e583770cb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66692b4f23353c9b1fe884e583770cb3">&#9670;&nbsp;</a></span>getSizeY() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Domain::getSizeY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the non-modifiable number of cells on the y-axis. </p>
<dl class="section return"><dt>Returns</dt><dd>number of cells on y-axis </dd></dl>

</div>
</div>
<a id="a6f7d5f16ca53367feabc00b9efa05be8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f7d5f16ca53367feabc00b9efa05be8">&#9670;&nbsp;</a></span>getUidList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned int &gt; Domain::getUidList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns vector containing unique ids of all cells. </p>
<dl class="section return"><dt>Returns</dt><dd>vector of uids of all domain cells (unordered) (unordered) </dd></dl>

</div>
</div>
<a id="ad99f85d4d30525bac3ac258a0032bdf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad99f85d4d30525bac3ac258a0032bdf7">&#9670;&nbsp;</a></span>getValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real Domain::getValue </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>quantityName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>uid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>onNext</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns non-modifiable quantity value of a cell given by its id. </p>
<p>/!\ Iterating over all cells with this function is much slower than iterating on SDDs and then getting values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quantityName</td><td>name of desired quantity </td></tr>
    <tr><td class="paramname">uid</td><td>unique id of desired cell </td></tr>
    <tr><td class="paramname">onNext</td><td>get value on current time step if == 0, on previous time step if == 1</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of quantity on desired cell </dd></dl>

</div>
</div>
<a id="a853266061b629ff1f920b46c06c478d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a853266061b629ff1f920b46c06c478d6">&#9670;&nbsp;</a></span>initRect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Domain::initRect </td>
          <td>(</td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>lx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>ly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>Nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>Ny</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes domain rectangle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lx</td><td>physical width of the domain </td></tr>
    <tr><td class="paramname">ly</td><td>physical width of the domain </td></tr>
    <tr><td class="paramname">Nx</td><td>number of cells on the x-axis </td></tr>
    <tr><td class="paramname">Ny</td><td>number of cells on the y-axis </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a853266061b629ff1f920b46c06c478d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a853266061b629ff1f920b46c06c478d6">&#9670;&nbsp;</a></span>initRect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Domain::initRect </td>
          <td>(</td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>lx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>ly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>Nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>Ny</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes domain rectangle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lx</td><td>physical width of the domain </td></tr>
    <tr><td class="paramname">ly</td><td>physical width of the domain </td></tr>
    <tr><td class="paramname">Nx</td><td>number of cells on the x-axis </td></tr>
    <tr><td class="paramname">Ny</td><td>number of cells on the y-axis </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1163559d75540c4cd29c7aa775feca80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1163559d75540c4cd29c7aa775feca80">&#9670;&nbsp;</a></span>printState() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Domain::printState </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>quantityName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints quantity values for all cells. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quantityName</td><td>name of quantity to print </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1163559d75540c4cd29c7aa775feca80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1163559d75540c4cd29c7aa775feca80">&#9670;&nbsp;</a></span>printState() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Domain::printState </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>quantityName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints quantity values for all cells. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quantityName</td><td>name of quantity to print </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a10a5e8384b21bb3c968699c2a6c89bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10a5e8384b21bb3c968699c2a6c89bf7">&#9670;&nbsp;</a></span>setOptions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Domain::setOptions </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nSDD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nSDD_X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nSDD_Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nSDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>SDSgeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nThreads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes options for building SDDs and SDSs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nSDD</td><td>number of SDDs on the domain </td></tr>
    <tr><td class="paramname">nSDD_X</td><td>number of SDDs along the x-axis </td></tr>
    <tr><td class="paramname">nSDD_Y</td><td>number of SDDs along the y-axis </td></tr>
    <tr><td class="paramname">nSDS</td><td>number of SDS per SDD </td></tr>
    <tr><td class="paramname">SDSgeom</td><td>type of SDS split </td></tr>
    <tr><td class="paramname">nThreads</td><td>number of threads per SDD </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a10a5e8384b21bb3c968699c2a6c89bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10a5e8384b21bb3c968699c2a6c89bf7">&#9670;&nbsp;</a></span>setOptions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Domain::setOptions </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nSDD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nSDD_X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nSDD_Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nSDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>SDSgeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nThreads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes options for building SDDs and SDSs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nSDD</td><td>number of SDDs on the domain </td></tr>
    <tr><td class="paramname">nSDD_X</td><td>number of SDDs along the x-axis </td></tr>
    <tr><td class="paramname">nSDD_Y</td><td>number of SDDs along the y-axis </td></tr>
    <tr><td class="paramname">nSDS</td><td>number of SDS per SDD </td></tr>
    <tr><td class="paramname">SDSgeom</td><td>type of SDS split </td></tr>
    <tr><td class="paramname">nThreads</td><td>number of threads per SDD </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc1225a3c5e6e2a808c88d187adc7d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc1225a3c5e6e2a808c88d187adc7d3c">&#9670;&nbsp;</a></span>setSDDInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Domain::setSDDInfo </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>BL_X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>BL_Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>Nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>Ny</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change characteristics of SDD (bottom-left and size) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BL_X</td><td>X-coordinate of bottom-left coords on domain </td></tr>
    <tr><td class="paramname">BL_Y</td><td>Y-coordinate of bottom-left coords on domain </td></tr>
    <tr><td class="paramname">Nx</td><td>width of SDD </td></tr>
    <tr><td class="paramname">Ny</td><td>height of SDD </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9319e738fbd4ada8145998d5392c9334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9319e738fbd4ada8145998d5392c9334">&#9670;&nbsp;</a></span>setValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Domain::setValue </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>quantityName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>uid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>onNext</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies quantity value of a cell given by its id. </p>
<p>/!\ Iterating over all cells with this function is much slower than iterating on SDDs and then setting values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quantityName</td><td>name of quantity to set </td></tr>
    <tr><td class="paramname">uid</td><td>unique id of cell to modify </td></tr>
    <tr><td class="paramname">new</td><td>value to set </td></tr>
    <tr><td class="paramname">onNext</td><td>get value on current time step if == 0, on previous time step if == 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af169473470489edc4235399887c10da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af169473470489edc4235399887c10da0">&#9670;&nbsp;</a></span>updateBoundaryCells() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Domain::updateBoundaryCells </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>quantityName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>changeNeumannToOpposite</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates boundary of all SDDs according to their values on reference cells on other SDDs, for a given quantity. </p>
<p>/!\ This has to be called AFTER updating overlap cells, since boundary // Updating umax for computation of the next dt _umax = std::max(_umax, std::abs(ux.get(0, i, j))); _umax = std::max(_umax, std::abs(uy.get(0, i, j)));</p>
<p>cells may be updated with values on overlap cells. The boolean parameter is optional and can be used for some physical quantities that require the Neumann boundary condition to be opposite.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quantityName</td><td>name of quantity to update </td></tr>
    <tr><td class="paramname">changeNeumannToOpposite</td><td>if true, this changes the value into its opposite on cells that have Neumann BC. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af169473470489edc4235399887c10da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af169473470489edc4235399887c10da0">&#9670;&nbsp;</a></span>updateBoundaryCells() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Domain::updateBoundaryCells </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>quantityName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>changeNeumannToOpposite</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates boundary of all SDDs according to their values on reference cells on other SDDs, for a given quantity. </p>
<p>/!\ This has to be called AFTER updating overlap cells, since boundary cells may be updated with values on overlap cells. The boolean parameter is optional and can be used for some physical quantities that require the Neumann boundary condition to be opposite.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quantityName</td><td>name of quantity to update </td></tr>
    <tr><td class="paramname">changeNeumannToOpposite</td><td>if true, this changes the value into its opposite on cells that have Neumann BC. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4411f8eb6c118c84f16d62a411b4432a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4411f8eb6c118c84f16d62a411b4432a">&#9670;&nbsp;</a></span>updateOverlapCells() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Domain::updateOverlapCells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates overlap cells of all SDDs according to their values on reference cells on other SDDs, for a given quantity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quantityName</td><td>name of quantity to update </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abcd8aa2529907b8022e41e45c85f5144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcd8aa2529907b8022e41e45c85f5144">&#9670;&nbsp;</a></span>updateOverlapCells() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Domain::updateOverlapCells </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>quantityName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates overlap cells of all SDDs according to their values on reference cells on other SDDs, for a given quantity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quantityName</td><td>name of quantity to update </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>source/subdomain/<a class="el" href="source_2subdomain_2Domain_8hpp_source.html">Domain.hpp</a></li>
<li>source/subdomain/Domain.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
