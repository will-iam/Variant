<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Variant: SDShared Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Variant
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classSDShared-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SDShared Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Subdomain on shared memory (SDS)  
 <a href="classSDShared.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="SDShared_8hpp_source.html">SDShared.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SDShared:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classSDShared.png" usemap="#SDShared_map" alt=""/>
  <map id="SDShared_map" name="SDShared_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afc8718fef97226eed215c34e1b453503"><td class="memItemLeft" align="right" valign="top"><a id="afc8718fef97226eed215c34e1b453503"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSDShared.html#afc8718fef97226eed215c34e1b453503">SDShared</a> (const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;coords, const <a class="el" href="classCoordConverter.html">CoordConverter</a> &amp;coordConverter, unsigned int index)</td></tr>
<tr class="memdesc:afc8718fef97226eed215c34e1b453503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor based on vector of coords. <br /></td></tr>
<tr class="separator:afc8718fef97226eed215c34e1b453503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a51f6ef83b411b8839a7953af5257d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSDShared.html#ab3a51f6ef83b411b8839a7953af5257d">getId</a> () const</td></tr>
<tr class="memdesc:ab3a51f6ef83b411b8839a7953af5257d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns SDS id.  <a href="#ab3a51f6ef83b411b8839a7953af5257d">More...</a><br /></td></tr>
<tr class="separator:ab3a51f6ef83b411b8839a7953af5257d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba4c821b3ee742a27d72d5401602d22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSDShared.html#a0ba4c821b3ee742a27d72d5401602d22">execEquation</a> (eqType &amp;eqFunc, const std::map&lt; std::string, <a class="el" href="classQuantity.html">Quantity</a>&lt; real &gt; * &gt; &amp;quantityMap)</td></tr>
<tr class="separator:a0ba4c821b3ee742a27d72d5401602d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07fd636017e1a465d537a2f21b1ef96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSDShared.html#ae07fd636017e1a465d537a2f21b1ef96">updateBoundaryCells</a> (<a class="el" href="classQuantity.html">Quantity</a>&lt; real &gt; *quantity, bool changeNeumannToOpposite=false) const</td></tr>
<tr class="memdesc:ae07fd636017e1a465d537a2f21b1ef96"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates boundary of all SDDs according to their values on reference cells on other SDDs, for a given quantity.  <a href="#ae07fd636017e1a465d537a2f21b1ef96">More...</a><br /></td></tr>
<tr class="separator:ae07fd636017e1a465d537a2f21b1ef96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadaccd75a835ca8436c223c56a791c89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSDShared.html#aadaccd75a835ca8436c223c56a791c89">updateNeumannCells</a> (<a class="el" href="classQuantity.html">Quantity</a>&lt; real &gt; *quantity, bool changeToOpposite=false) const</td></tr>
<tr class="memdesc:aadaccd75a835ca8436c223c56a791c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates Neumann boundary cells of SDD according to values stored in memory.  <a href="#aadaccd75a835ca8436c223c56a791c89">More...</a><br /></td></tr>
<tr class="separator:aadaccd75a835ca8436c223c56a791c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c83e8c7a830c2febcfc944f57fe158b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSDShared.html#a0c83e8c7a830c2febcfc944f57fe158b">updateDirichletCells</a> (<a class="el" href="classQuantity.html">Quantity</a>&lt; real &gt; *quantity) const</td></tr>
<tr class="memdesc:a0c83e8c7a830c2febcfc944f57fe158b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates Dirichlet boundary cells of SDD according to values stored in memory.  <a href="#a0c83e8c7a830c2febcfc944f57fe158b">More...</a><br /></td></tr>
<tr class="separator:a0c83e8c7a830c2febcfc944f57fe158b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa670f9d64ac7c03f9964ee0caa26f74c"><td class="memItemLeft" align="right" valign="top"><a id="aa670f9d64ac7c03f9964ee0caa26f74c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addDirichletCell</b> (std::pair&lt; std::pair&lt; int, int &gt;, real &gt; d)</td></tr>
<tr class="separator:aa670f9d64ac7c03f9964ee0caa26f74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5af3b277896ecbbca23d5df0c23b97"><td class="memItemLeft" align="right" valign="top"><a id="a5e5af3b277896ecbbca23d5df0c23b97"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addNeumannCell</b> (std::pair&lt; std::pair&lt; int, int &gt;, std::pair&lt; int, int &gt; &gt; n)</td></tr>
<tr class="separator:a5e5af3b277896ecbbca23d5df0c23b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bab738ad8c008e621b40505f3db145c"><td class="memItemLeft" align="right" valign="top"><a id="a3bab738ad8c008e621b40505f3db145c"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>getNumberBoundaryCells</b> () const</td></tr>
<tr class="separator:a3bab738ad8c008e621b40505f3db145c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7b516e808d3a4781f94d9a50763e2c"><td class="memItemLeft" align="right" valign="top"><a id="a8a7b516e808d3a4781f94d9a50763e2c"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>convert</b> (int coordX, int coordY) const</td></tr>
<tr class="separator:a8a7b516e808d3a4781f94d9a50763e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f6a437419391d952839262b57e29161"><td class="memItemLeft" align="right" valign="top"><a id="a7f6a437419391d952839262b57e29161"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setBufferPos</b> (unsigned int sddId, size_t pos)</td></tr>
<tr class="separator:a7f6a437419391d952839262b57e29161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b518a2b0779864a5156dde19dd4911"><td class="memItemLeft" align="right" valign="top"><a id="aa1b518a2b0779864a5156dde19dd4911"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>getOverlapCellNumber</b> (unsigned int sddId) const</td></tr>
<tr class="separator:aa1b518a2b0779864a5156dde19dd4911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f7996970b7ce7a65b5fdf224ee8f6f3"><td class="memItemLeft" align="right" valign="top"><a id="a5f7996970b7ce7a65b5fdf224ee8f6f3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addOverlapCell</b> (unsigned int sddId, size_t sendIndex, size_t recvIndex)</td></tr>
<tr class="separator:a5f7996970b7ce7a65b5fdf224ee8f6f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a304e9ff7e7a4b612ad75b3770bfc634b"><td class="memItemLeft" align="right" valign="top"><a id="a304e9ff7e7a4b612ad75b3770bfc634b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>copyOverlapCellIn</b> (const std::map&lt; std::string, <a class="el" href="classQuantity.html">Quantity</a>&lt; real &gt; * &gt; &amp;quantityMap, const std::unordered_map&lt; unsigned int, real * &gt; &amp;buffer) const</td></tr>
<tr class="separator:a304e9ff7e7a4b612ad75b3770bfc634b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3038fcccd20d251e4fbe98e31b89faf6"><td class="memItemLeft" align="right" valign="top"><a id="a3038fcccd20d251e4fbe98e31b89faf6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>copyOverlapCellFrom</b> (const std::map&lt; std::string, <a class="el" href="classQuantity.html">Quantity</a>&lt; real &gt; * &gt; &amp;quantityMap, const std::unordered_map&lt; unsigned int, real * &gt; &amp;buffer) const</td></tr>
<tr class="separator:a3038fcccd20d251e4fbe98e31b89faf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Subdomain on shared memory (SDS) </p>
<p>Defines a subdomain on shared memory. Since the data is stored as one block on the SDD, a SDS is only an array of 2D-coordinates referencing to cells of the SDD. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a0ba4c821b3ee742a27d72d5401602d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ba4c821b3ee742a27d72d5401602d22">&#9670;&nbsp;</a></span>execEquation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SDShared::execEquation </td>
          <td>(</td>
          <td class="paramtype">eqType &amp;&#160;</td>
          <td class="paramname"><em>eqFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="classQuantity.html">Quantity</a>&lt; real &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>quantityMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>exec equation on SDS to be added as thread task </p>

</div>
</div>
<a id="ab3a51f6ef83b411b8839a7953af5257d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3a51f6ef83b411b8839a7953af5257d">&#9670;&nbsp;</a></span>getId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int SDShared::getId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns SDS id. </p>
<dl class="section return"><dt>Returns</dt><dd>id of SDS </dd></dl>

</div>
</div>
<a id="ae07fd636017e1a465d537a2f21b1ef96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae07fd636017e1a465d537a2f21b1ef96">&#9670;&nbsp;</a></span>updateBoundaryCells()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SDShared::updateBoundaryCells </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQuantity.html">Quantity</a>&lt; real &gt; *&#160;</td>
          <td class="paramname"><em>quantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>changeNeumannToOpposite</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates boundary of all SDDs according to their values on reference cells on other SDDs, for a given quantity. </p>
<p>/!\ This has to be called AFTER updating overlap cells, since boundary <br />
 _umax = std::max(_umax, std::abs(uy.get(0, i, j)));</p>
<p>cells may be updated with values on overlap cells. The boolean parameter is optional and can be used for some physical quantities that require the Neumann boundary condition to be opposite.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quantityName</td><td>name of quantity to update </td></tr>
    <tr><td class="paramname">changeNeumannToOpposite</td><td>if true, this changes the value into its opposite on cells that have Neumann BC. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c83e8c7a830c2febcfc944f57fe158b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c83e8c7a830c2febcfc944f57fe158b">&#9670;&nbsp;</a></span>updateDirichletCells()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SDShared::updateDirichletCells </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQuantity.html">Quantity</a>&lt; real &gt; *&#160;</td>
          <td class="paramname"><em>quantity</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates Dirichlet boundary cells of SDD according to values stored in memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quantityName</td><td>str. name of quantity to update </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aadaccd75a835ca8436c223c56a791c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadaccd75a835ca8436c223c56a791c89">&#9670;&nbsp;</a></span>updateNeumannCells()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SDShared::updateNeumannCells </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQuantity.html">Quantity</a>&lt; real &gt; *&#160;</td>
          <td class="paramname"><em>quantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>changeToOpposite</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates Neumann boundary cells of SDD according to values stored in memory. </p>
<p>This does not require communication with other SDDs as long as overlap cells were update before.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quantityName</td><td>str. name of quantity to update </td></tr>
    <tr><td class="paramname">changeToOpposite</td><td>change to opposite value of reference according to value. This depends on the boundary and is useful for quantities traditionnally defined on edges. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>source/subdomain/<a class="el" href="SDShared_8hpp_source.html">SDShared.hpp</a></li>
<li>source/subdomain/SDShared.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
