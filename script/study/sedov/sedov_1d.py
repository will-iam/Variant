import numpy as npfrom globalvars import comvars as gvfrom scipy import (integrate, optimize)def sedov_funcs(v):    '''    Given the similarity variable v, return functions, lambda, f, g, h, and th derivative of lambda with v dlamdv    although the ordinary differential equations are analytic, the sedov expressions    appear to become singular for various combinations of parameters and at the lower     limits of the integration range.  all these singularaties are rtemovable and done by this routine    frequent combintaion and their derivative with v    kamm equations 29 - 32, x4 a bit different to save a divide    '''    # x1 is book's F    x1 = gv.a_val * v    dx1dv = gv.a_val    cbag = max(gv.eps, gv.c_val * v - 1.0E0)    x2 = gv.b_val * cbag    dx2dv = gv.b_val * gv.c_val    ebag = 1.0E0 - gv.e_val * v    x3 = gv.d_val * ebag    dx3dv = -gv.d_val * gv.e_val    x4 = gv.b_val * (1.0E0 - 0.5E0 * gv.xg2 * v)    dx4dv = - gv.b_val* 0.5E0 * gv.xg2    ##transition region between standard and vacuum cases    ##kamm page 15 or equations 88-92    ##lambds = l_fun is book's zeta    ##f_fun is book's V, g_fun is book's D, h_fun is book's P    if gv.lsingular == True:        l_fun = gv.rwant/gv.r2        dlamdv = 0.0E0        f_fun = l_fun        g_fun = l_fun**(gv.xgeom - 2.0E0)        h_fun = l_fun**gv.xgeom    ##for the vacuum case in the hole    elif gv.lvacuum and gv.rwant < gv.rvv:        l_fun = 0.0E0        dlamdv = 0.0E0        f_fun = 0.0E0        g_fun = 0.0E0        h_fun = 0.0E0    ##omega = omega2 = (2*(gamma - 1)+xgeom)/gamma case, denom2 = 0    ##book expressions 20-22    elif gv.lomega2 == True:        beta0 = 1.0E0 / (2.0E0 * gv.e_val)        pp1 = gv.gamm1 * beta0         c6 = 0.5E0 * gv.gamp1        c2 = c6 / gv.gamma        y = 1.0E0 / (x1 - c2)        z = (1.0E0 - x1)*y        pp2 = gv.gamp1 * beta0 * z        dpp2dv = -gv.gamp1 * beta0 * dx1dv * y * (1.0E0 + z)        pp3 = (4.0E0 - gv.xgeom - 2.0E0*gv.gamma) * beta0        pp4 = -gv.xgeom * gv.gamma * beta0        l_fun = x1**(-gv.a0) * x2**(pp1) * np.exp(pp2)        dlamdv = (-gv.a0*dx1dv/x1 +pp1*dx2dv/x2 + dpp2dv) * l_fun        f_fun = x1 * l_fun        g_fun = x1**(gv.a0*gv.omega) * x2**pp3 * x4**gv.a5 * np.exp(-2.0E0*pp2)        h_fun = x1**(gv.a0*gv.xgeom) * x2**pp4 * x4**(1.0E0 +gv.a5)    ##omega = omega3 = xgeom*(2-gamma) case, denom3 = 0    ##book expressions 23-25    elif gv.lomega3 == True:        beta0 = 1.0E0/ (2.0E0 * gv.e_val)        pp1 = gv.a3 + gv.omega * gv.a2        pp2 = 1.0E0 - 4.0E0 * beta0        c6 = 0.5E0 * gv.gamp1        pp3 = -gv.xgeom * gv.gamma * gv.gamp1 * beta0 * (1.0E0 - x1)/(c6 - x1)        pp4 = 2.0E0 * (gv.xgeom * gv.gamm1 - gv.gamma) * beta0        l_fun = x1**(-gv.a0) * x2**(-gv.a2) * x4**(-gv.a1)        dlamdv = -(gv.a0*dx1dv/x1 + gv.a2*dx2dv/x2 + gv.a1*dx4dv/x4) * l_fun        f_fun = x1 * l_fun        g_fun = x1**(gv.a0*gv.omega) * x2**pp1 * x4**pp2 * np.exp(pp3)        h_fun = x1**(gv.a0*gv.xgeom) * x4**pp4 * np.exp(pp3)    ##for the standard or vacuum case not in the hole    ##kamm equations 38 - 41    else:        l_fun = x1**(-gv.a0) * x2**(-gv.a2) * x3**(-gv.a1)        dlamdv = -(gv.a0*dx1dv/x1 + gv.a2*dx2dv/x2 + gv.a1*dx3dv/x3) * l_fun        f_fun = x1 * l_fun        g_fun = x1**(gv.a0*gv.omega) * x2**(gv.a3 + gv.a2 * gv.omega) * x3**(gv.a4 +gv.a1 * gv.omega) * x4**gv.a5        h_fun = x1**(gv.a0*gv.xgeom) * x3**(gv.a4 + gv.a1 *(gv.omega - 2.0E0)) * x4**(1.0E0 + gv.a5)    return l_fun, dlamdv, f_fun, g_fun, h_fundef sed_v_find(v):    '''    Given corresponding physical distances, find the similarity variable v    kamm equation 38 as a root find    '''    l_fun, dlamdv, f_fun, g_fun, h_fun = sedov_funcs(v)    v_find = gv.r2*l_fun - gv.rwant    return v_find    def sed_r_find(r):    '''    Given the similarity variably v, find the sorrespoding physical distance    kamm equation 38 as a root find    '''    l_fun, dlamdv, f_fun, g_fun, h_fun = sedov_funcs(gv.vwant)    r_find = gv.r2*l_fun - r    return r_finddef efun01(v):       '''    Evaluates the first energy integrand, kamm equations 67 and 10.    the (c_val*v - 1) term might be singular at v=vmin in the standard case    the (1- c_val/gamma *v) term might be singular at v=vmin in the vacuum case    due care should be taken for these removable singularities by the integrator    '''    l_fun, dlamdv, f_fun, g_fun, h_fun = sedov_funcs(v)    efun1 = dlamdv * l_fun**(gv.xgeom + 1.0E0) * gv.gpogm * g_fun * v**2    return efun1    def efun02(v):     '''    Evaluates the first energy integrand, kamm equations 68 and 11.    the (c_val*v - 1) term might be singular at v=vmin in the standard case    the (1- c_val/gamma *v) term might be singular at v=vmin in the vacuum case    due care should be taken for these removable singularities by the integrator    '''    l_fun, dlamdv, f_fun, g_fun, h_fun = sedov_funcs(v)    z = 8.0E0/((gv.xgeom + 2.0E0 - gv.omega)**2 * gv.gamp1)    efun2 = dlamdv * l_fun**(gv.xgeom - 1.0E0) * h_fun * z    return efun2def sed_1d(time, nstep, xpos, eblast, rho0, vel0, ener0, pres0, gv):    '''              #..this routine produces 1d solutions for a sedov blast wave propagating    #..through a density gradient rho = rho**(-omega)    #..in planar, cylindrical or spherical geometry    #..for the standard, singular and vaccum cases.    #    #..standard case: a nonzero solution extends from the shock to the origin,    #.. where the pressure is finite.    #..singular case: a nonzero solution extends from the shock to the origin,    #.. where the pressure vanishes.    #..vacuum case : a nonzero solution extends from the shock to a boundary point,    #.. where the density vanishes making the pressure meaningless.    #    #..input:    #..time = temporal point where solution is desired seconds    #..xpos(i) = spatial points where solution is desired cm    #..eblast = energy of blast erg    #..rho0 = ambient density g/cm**3 rho = rho0 * r**(-omega_in)    #..omegain = density power law exponent rho = rho0 * r**(-omega_in)    #..vel0 = ambient material speed cm/s    #..pres0 = ambient pressure erg/cm**3    #..gam0 = gamma law equation of state    #..xgeom_in = geometry factor, 3=spherical, 2=cylindircal, 1=planar    #    #..for efficiency reasons (doing the energy integrals only once),    #..this routine returns the solution for an array of spatial points    #..at the desired time point.    #    #..output:    #..den(i) = density     #..enertot(i) = specific internal energy     #..pres(i) = presssure     #..vel(i) = velocity     #..mach(i) = mach number     #    #..although the ordinary differential equations are analytic,    #..the sedov expressions appear to become singular for various    #..combinations of parameters and at the lower limits of the integration    #..range. all these singularies are removable and done so by this routine.    #..these routines are written in real*16 precision because the    #..real*8 implementations simply run out of precision "near" the origin    #..in the standard case or the transition region in the vacuum case.    #    #..eps controls the integration accuracy, don't get too greedy or the number    #..of function evaluations required kills.    #..eps2 controls the root find accuracy    #..osmall controls the size of transition regions    '''    iprint = 1    gv.eps = 1.0E-10    eps2 = 1.0E-30    osmall = 1.0E-4    #==============================================================================    ##original code common block             #==============================================================================    #                    #               global gamma, gamm1, gamp1, gpogm, xgeom, xg2, rwant    #                global r2, a0, a1, a2, a3, a4, a5, a_val, b_val, cval_    #                global d_val, e_val, omega, vv, xlam_want, vwant, rvv    #                global lsingular, lstandard, lvacuum, lomega2, lomega3    #    #create initial arrays of  density, velocity, pressure, energy, and sound speed.    #initally create arrays of zeros.                    den = np.zeros(nstep)    vel = np.zeros(nstep)    pres = np.zeros(nstep)    enertot = np.zeros(nstep)    ##return on uynphysical cases    ##infinite mass    if gv.omega >= gv.xgeom:        return    ##transfer through comon block and create some frequent combonations.    #common block from original code is now emulated by global varibles.    gv.gamm1 = gv.gamma - 1.0E0    gv.gamp1 = gv.gamma + 1.0E0    gv.gpogm = gv.gamp1 / gv.gamm1    gv.xg2 = gv.xgeom + 2.0E0 - gv.omega    denom2 = 2.0E0 * gv.gamm1 + gv.xgeom - gv.gamma * gv.omega    denom3 = gv.xgeom * (2.0E0 - gv.gamma) - gv.omega    ## post shock location v2 and location of singular point vstar    ## kamm equations 18 and 19    v2 = 4.0E0 / (gv.xg2 * gv.gamp1)    vstar = 2.0E0 / (gv.gamm1*gv.xgeom + 2.0E0)    ##set two logicals to determine type of solution    gv.lstandard = False    gv.lsingular = False    gv.lavcuum = False    if abs(v2 - vstar) <= osmall:        gv.lsingular = True    elif v2 < vstar - osmall:        gv.lstandard = True    elif v2 > vstar + osmall:        gv.lvacuum = True    ##two apparent singularities, books notation for omega2 and omega3    gv.lomega2 = False    gv.lomega3 = False    if abs(denom2) <= osmall:        gv.lomega = True        denom2 = 1.0E-8        if iprint == 1:            print('omega2 case')    elif abs(denom3) <= osmall:        gv.lomega3 = True        denom3 = 1.0E-8        if iprint == 1:            print('omega3 case')    ##various exponents, kamm equations 42-47    gv.a0 = 2.0E0/gv.xg2    gv.a2 = -gv.gamm1/denom2    gv.a1 = (gv.xg2*gv.gamma/(2.0E0 + gv.xgeom*gv.gamm1)) * (((2.0E0*(gv.xgeom*(2.0E0-gv.gamma)-gv.omega))/(gv.gamma*gv.xg2**2))-gv.a2)    gv.a3 = (gv.xgeom - gv.omega) / denom2    gv.a4 = gv.xg2 * ( gv.xgeom - gv.omega) * gv.a1/denom3    gv.a5 = ((gv.omega * gv.gamp1) - (2.0E0 * gv.xgeom)) / denom3    ##frequent combinations, kamm equations 33-37    gv.a_val = 0.25E0 * gv.xg2 * gv.gamp1    gv.b_val = gv.gpogm    gv.c_val = 0.5E0 * gv.xg2 * gv.gamma    gv.d_val = (gv.xg2 * gv.gamp1)/((gv.xg2 * gv.gamp1) - 2.0E0*(2.0E0 + (gv.xgeom*gv.gamm1)))    gv.e_val = 0.5E0 * (2.0E0 + (gv.xgeom * gv.gamm1))    ##evaluate energy intergrals    ##the singular case can be done by hand; save some cpu cycles    ##kamm equations 80, 81, and 85    if gv.lsingular == True:        eval2 = gv.gamp1/(gv.xgeom*((gv.gamm1*gv.xgeom)+2.0E0)**2)        eval1 = 2.0E0 / gv.gamm1 * eval2        alpha = gv.gpogm* 2**(gv.xgeom) / (gv.xgeom*((gv.gamm1*gv.xgeom)+2.0E0)**2)        if int(gv.xgeom) != 1:            alpha = np.pi * alpha    ## for standard or vacuum cases    ## v0 = post-shock orgin v0 and vv = vacuum boundry vv    ## set the radius(rvv) coresponding to vv to 0 for now    ## kamm equations 18, and 20    else:        v0 = 2.0E0 / (gv.xg2 * gv.gamma)        gv.vv = 2.0E0 / gv.xg2        gv.rvv = 0.0E0        if gv.lstandard == True:            vmin = v0        if gv.lvacuum == True:            vmin = gv.vv        ##the first energy integral        ##in standard case the term (c_val*v - 1) might be singular at v = vmin        ##kamm equations 18 and 28        #qromo subroutine from original code is replaced by romberg routine from scipy.integrate        eval1 = integrate.romberg(efun01, vmin, v2, tol = gv.eps, divmax = gv.its)                           ##in the vacuum case the term (1-c_val/gamma*v) might be singular at v=vmin        ##in the standard case the term ( c_val * v-1) might be singular at v=vmin        eval2 = integrate.romberg(efun02, vmin, v2, tol = gv.eps, divmax = gv.its)    ##in the vacuum case the term (1-c_val/gamma*v) might be singular at v=vmin    ## kamm equations 57n and 58 for alpha in a slightly different form    if gv.xgeom == 1.0:        alpha = (0.5E0 * eval1) + (eval2 / gv.gamm1)    else:        alpha = (gv.xgeom - 1.0E0) * np.pi * (eval1 + 2.0E0 * eval2/gv.gamm1)    ##write what we have for the energy intergrals    if iprint == 1:        print('xgeom=', gv.xgeom)        print('eblast=', eblast)        print('omega=', gv.omega)        print('alpha=', alpha)        print('j1=', eval1)        print('j2=', eval2)    ##immediate post-shock values    ##kamm page 14 or equations 14, 16, 5, 13    ##r2 = shock position, us = shock spees, rho1 = pre-shock density    ##u2 = post-shock material speed, rho2 = post-shock density    ##p2 = post-shock pressure, e2 = post-shock specific internal energy    ##adn cs2 = post-shock sound speed    gv.r2 = (eblast/(alpha*rho0))**(1.0 / gv.xg2) * time**(2.0 / gv.xg2)    us = (2.0E0/gv.xg2) * gv.r2/time    rho1 = rho0 * gv.r2**(-gv.omega)    u2 = 2.0E0 * us / gv.gamp1    rho2 = gv.gpogm * rho1    p2 = 2.0E0 * rho1 * us**2 / gv.gamp1    e2 = p2/(gv.gamm1*rho2)    cs2 = np.sqrt(gv.gamma*p2/rho2)    ##find the radius corresponding to vv    #sub routine zeroin from original code is replaced by the brenth function from scipy.integrate    if gv.lvacuum == True:        gv.vwant = gv.vv        gv.rvv = optimize.brenth(sed_r_find, 0.0E0, gv.r2, xtol = gv.eps)    #print various values    if gv.lstandard == True and iprint == 1:        print('r2=', gv.r2)        print('rho2=', rho2)        print('u2=', u2)        print('e2=', e2)        print('p2=', p2)        print('cs2=', cs2)    if gv.lvacuum == True and iprint ==1:        print('rv=', gv.rvv)        print('r2=', gv.r2)        print('rho2=', rho2)        print('u2=', u2)        print('e2=', e2)        print('p2=', p2)        print('cs2=', cs2)    ##now start loop over spatial positions    for i in range(0, nstep):        gv.rwant = xpos[i]        ##if we are upstream from the shock        # area not yet disturbed by shock front        if gv.rwant >= gv.r2:            den[i] = rho0 * gv.rwant**(-gv.omega)            vel[i] = vel0            pres[i] = pres0            enertot[i] = ener0        #check to see if solutions are valid in region,  if not delete the point from the array        #this will prevent python from stoping the code, and allow for solutions to be produced in valid regions.        #if statemant checks if sed_v_find are the same sign at two points( 0.9*v0 and v2)        elif sed_v_find(0.9E0*v0)/sed_v_find(v2) > 0:            xpos[i] = 0.0            den[i] = 0.0            vel[i] = 0.0            pres[i] = 0.0            enertot[i] = 0.0        ##if we are between the origin and the shock front        else:            if gv.lstandard == True:                vat = optimize.brenth(sed_v_find, 0.90E0*v0, v2, xtol=eps2)            elif gv.lvacuum == True:                vat = optimize.brenth(sed_v_find, v2, 1.2E0*gv.vv, xtol=eps2)            ##the pysical solution            l_fun, dlamdv, f_fun, g_fun, h_fun = sedov_funcs(vat)            den[i] = rho2 * g_fun            vel[i] = u2 * f_fun            pres[i] = p2 * h_fun            enertot[i] = 0.0            if den[i] != 0.0:                enertot[i] = pres[i]/(gv.gamm1) + 0.5E0 * den[i] * (vel[i])**2    ## end loop over spatial positions    return den, vel, pres, enertot, xpos